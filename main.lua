io.stdout:setvbuf('no')
print(os.date('%c'), 'initializing experiment')
require 'paths'
cjson = require 'cjson'
local function read_file(filepath)
    local file = torch.DiskFile(filepath, 'r')
    return file:readString('*a')
end
local cmd = torch.CmdLine()
cmd:text()
cmd:text('Run a single experiment, with experimental options passed via json.')
cmd:text()
cmd:text('Options:')
cmd:option('--json', '', 'The experimental hyperparameters in json')
cmd:option('--optfile', '', 'The json args stored in a file. ' ..
                            'Takes precedence over `json`')
cmd:option('--outfile', '', 'file to store the experiment results in')
cmd:option('--exp_id', '', 'manually assign exp_id; overrides autogenerated exp_id')
cmd:text()
local cmd_opts = cmd:parse(arg)
print(cmd_opts)
local json_args = nil
if #cmd_opts.optfile > 0 then
    if not pcall(function() json_args = read_file(cmd_opts.optfile) end) then
        error('--optfile ' .. cmd_opts.optfile .. ' does not contain valid json')
    end
elseif cmd_opts.json then
    json_args = cmd_opts.json
else
    error('No valid experiment arguments given.')
end

train = paths.dofile('train.lua')
train.imports()

print(os.date('%c'))
preopt = cjson.decode(json_args)
-- pretty print
pp.tb(preopt)
if cmd_opts.exp_id ~= '' then
    print('overriding opt exp_id with commandline argument', cmd_opts.exp_id)
    preopt.exp_id = cmd_opts.exp_id
end
__opt = options.get_opt(Om(preopt), true)
__opt = Om(__opt):sort(operator.lt)

print(os.date('%c'), tostring(__opt))


torch.manualSeed(__opt.seed)
train.gpu()

train.load_or_create()
train.pool_params()
train.reinit_params()
train.clone()
__fb = dofile('fb.lua')
__fb.init(__opt, __model.init_states)
train.init_metadata()

print(os.date('%c'), 'begin training loop')
success, err = pcall(function()
        while __xstate.iter <= __opt.max_iter
        do
            train.looptrain()
            local t = __xstate.train_losses[__xstate.iter - 1]
            if utils.isnan(t) or not utils.isfinite(t) then
                break
            end
        end
    end)
-- results does not contain xstate.vis
local results = utils.captureresults{keys2str=true}
pp.tb(results)
if not success then
    print(err)
end
if #cmd_opts.outfile > 0 then
    local file = torch.DiskFile(cmd_opts.outfile, 'w')
    cjson.encode_sparse_array(true)
    local xinfo = {opt=__opt, results=results}
    if __opt.run_vis then
        xinfo.vis = __xstate.vis
    end
    file:writeString(cjson.encode(xinfo))
    file:close()
end
print(os.date('%c'), 'done')
